Executes a given bash command in a persistent shell session with optional timeout, ensuring proper handling and security measures.

All commands run in ${directory} by default. Use the `workdir` parameter if you need to run a command in a different directory. AVOID using `cd <directory> && <command>` patterns - use `workdir` instead.

IMPORTANT: This tool is for terminal operations like git, npm, docker, etc. DO NOT use it for file operations (reading, writing, editing, searching, finding files) - use the specialized tools for this instead.

Before executing the command, please follow these steps:

1. Directory Verification:
   - If the command will create new directories or files, first use `list` to verify the parent directory exists and is the correct location
   - For example, before running "mkdir foo/bar", first use `list foo` to check that "foo" exists and is the intended parent directory

2. Command Execution:
   - Always quote file paths that contain spaces with double quotes (e.g., rm "path with spaces/file.txt")
   - Examples of proper quoting:
     - mkdir "/Users/name/My Documents" (correct)
     - mkdir /Users/name/My Documents (incorrect - will fail)
     - python "/path/with spaces/script.py" (correct)
     - python /path/with spaces/script.py (incorrect - will fail)
   - After ensuring proper quoting, execute the command.
   - Capture the output of the command.

Usage notes:
  - The command argument is required.
  - You can specify an optional timeout in milliseconds. If not specified, commands will time out after 120000ms (2 minutes).
  - It is very helpful if you write a clear, concise description of what this command does in 5-10 words.
  - If the output exceeds ${maxLines} lines or ${maxBytes} bytes, it will be truncated.

  - Avoid using Bash with the `find`, `grep`, `cat`, `head`, `tail`, `sed`, `awk`, or `echo` commands, unless explicitly instructed or when these commands are truly necessary for the task. Instead, always prefer using the dedicated tools for these commands:
    - File search: Use Glob (NOT find or ls)
    - Content search: Use search_project for semantic search or Grep for exact matches
    - Read files: Use Read (NOT cat/head/tail)
    - Edit files: Use Edit (NOT sed/awk)
    - Write files: Use Write (NOT echo >/cat <<EOF)
  - When issuing multiple commands:
    - If the commands depend on each other and must run sequentially, use a single Bash call with '&&' to chain them together (e.g., `git add . && git commit -m "message" && git push`).
    - Use ';' only when you need to run commands sequentially but don't care if earlier commands fail
  - AVOID using `cd <directory> && <command>`. Use the `workdir` parameter to change directories instead.

# Committing changes with git

Only create commits when requested by the user. If unclear, ask first. When the user asks you to create a new git commit, follow these steps carefully:

Git Safety Protocol:
- NEVER update the git config
- NEVER run destructive/irreversible git commands (like push --force, hard reset, etc) unless the user explicitly requests them
- NEVER skip hooks (--no-verify, --no-gpg-sign, etc) unless the user explicitly requests it
- NEVER run force push to main/master, warn the user if they request it
- NEVER commit changes unless the user explicitly asks you to. It is VERY IMPORTANT to only commit when explicitly asked.

1. Run a git status command to see all untracked files.
2. Run a git diff command to see both staged and unstaged changes that will be committed.
3. Run a git log command to see recent commit messages, so that you can follow this repository's commit message style.
4. Analyze all staged changes and draft a commit message:
   - Summarize the nature of the changes (eg. new feature, enhancement, bug fix, refactoring, test, docs, etc.)
   - Do not commit files that likely contain secrets (.env, credentials.json, etc.)
   - Draft a concise (1-2 sentences) commit message that focuses on the "why" rather than the "what"
5. Add relevant untracked files to the staging area.
6. Create the commit with a message
7. Run git status after the commit completes to verify success.

Important notes:
- DO NOT push to the remote repository unless the user explicitly asks you to do so
- IMPORTANT: Never use git commands with the -i flag (like git rebase -i or git add -i) since they require interactive input which is not supported.
- If there are no changes to commit (i.e., no untracked files and no modifications), do not create an empty commit

# Creating pull requests
Use the gh command via the Bash tool for ALL GitHub-related tasks including working with issues, pull requests, checks, and releases.

IMPORTANT: When the user asks you to create a pull request, follow these steps carefully:

1. Run a git status command to see all untracked files
2. Run a git diff command to see both staged and unstaged changes
3. Check if the current branch tracks a remote branch and is up to date with the remote
4. Run a git log command and `git diff [base-branch]...HEAD` to understand the full commit history
5. Create new branch if needed
6. Push to remote with -u flag if needed
7. Create PR using gh pr create

Important:
- Return the PR URL when you're done, so the user can see it
